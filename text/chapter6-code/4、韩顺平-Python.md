# 韩顺平 - Python 笔记记录

## 结合实际工作，快速掌握语言技术的方法

1、学语言，总是有一个需求的（工作需求/跳槽需求/技术控）
2、需求产生后，先看看使用现有技术是否可以解决（思考完之后，会有一种强烈的学习技术的必要性）
2.1、可以解决，但不够完美；2.2、不能解决
3、引出要学习的技术/知识点
4、先学习新技术知识点的基本原理和基本语法（这个时候不要考虑细节）
5、了解了之后，快速入门，完成基本程序，完成CRUD
5.1、比如说mysql先写一个基本的增删改查；可以有一个整体的感觉；首先*能跑就行* 
6、开始研究技术的注意事项、使用细节、使用规范、如何优化
6.1、这个部分没有止境，可以不断提升。这就是程序员之间的差距，他们看到的东西不一样
初级程序员可能只能看到1、2点，高级程序员可以看到6、7点



## 快捷键

ctrl + d：复制当前行
shift + delete：删除当前行
格式化代码：ctrl + alt + l
alt + r：快速运行程序
ctrl + h：查看类的层级关系
ctrl + r：替换

## 转义字符

\t：制表位
\n：换行符
\ \ ：输出斜杠
\ " ：输出引号
\r：回车，覆盖当前行的前面内容
这部分需要在引号里面引起来

## 注释 的一个小细节

在文件开头加上 #coding:编码
既可用来指定文件的类型

## 文档的查看和使用

## 计算机内存

计算机中所有的程序运行都在内存中进行：
代码→加载到内存→执行
知识→加载到记忆/大脑→执行

关于这部分的东西，是计算机组成原理的课程

![image-20250912093008979](/images/image-20250912093008979.png)

## 格式化输出

1、%操作符输出：

age = 80
score = 77.5
gender = "男"
name = "贾宝玉"
print("个人信息： %s %d %s %.2f" % (name ,age ,gender, score))

%s等内容就是占位符，s 是字符串，d是整数型，.2f是浮点数，后面有几个小数
中间的间隔（%s和%d），可以自己定义

2、format() 函数：

print("个人信息：{} {} {}".format(填充具体内容) )
后面format的内容，少了不可以，但是多了可以不报错

3、f-strings：（推荐）

print(f"个人信息：{name} {age} {gender} {score}")
加了 f ，含义会发生变化
就可以直接在引号里面使用大括号，然后对应具体的变量
**这个可以常用**

## 加号的使用

左右两边都是数值型（小数、整数），就是加法运算
左右两边都是字符串，拼接运算

## 数据类型

a是变量，变量本身是没有类型的，他可以随意更改指向的内容
但是a变量指向的数据，是有类型的

可以通过type()函数查看数据类型（本质是查看变量指向的数据类型）

### 进制

十六进制：前缀0x，由0-9和A-F组合
八进制：0o，由0-7组合
二进制：0b，由0 1组合

### 字节

编程中，存储数据的基本单位是字节（byte）
1 byte = 8 bit（位）

### 科学计数法

5.12e2：5.12乘以10的二次方
5.12E-2：5.12除以10的二次方

### 浮点数精度损失问题

可以使用Decimal 类进行精确计算
先进行导入，然后再使用

### 布尔值数值

1、Python会将true视为1，将false视为0
于是print(true + 10) #结果就是11

2、Python中，非0被视为真值，0被视为假值
if 0:
	print #不输出
if -1:
	#输出
if "字符串也可以"

### 字符串使用

"jack说'我在这里' "
变量名 = """中间可以放复杂的内容"""

如果使用转义字符的话，不想这个转义字符被使用，就可以在字符串前面加上一个r，即可

## 扩展知识

有点难，掌握了肯定是对后面理解知识有帮助的；但如果没有掌握，也没有关系，对后面影响微乎其微

### 驻留机制

内存中区分空间，是靠地址来的

![内存地址示意图](/images/image-20250912103934336.png)
不同的变量名(指针)都指向同一个空间

驻留机制的几种情况：
1、字符串是由26个英文字母大小写、0-9、_组成的时候
2、字符串长度为0或1时
3、字符串在编译时进行驻留（运行之前就已经知道是什么了），运行时不驻留
4、[-5，256]之间的整数数字
有时候会有意外情况，是pycharm进行了优化

如果想要在命令行窗口强制一样，可以使用sys.intern()

## 数据类型转换

### 隐式类型转换

Python变量的类型不固定，会根据变量当前值在运行时候进行决定
这期间可以通过type()函数进行查看。也叫自动转换

在进行运算的时候，数据类型会向高精度自动转换
比如int和float相加，精度会变成float

### 显式类型转换

i = 10
j = float(i)
主动进行转换

#### 注意事项

1、不管什么值的int、float都可以转成str，str(x)将对象x转成字符串
在Python中，一切皆为对象

2、int和float互转的时候，精度会有所变化

3、str转int、float的时候，使用int(x)等，可以转成。但是如果str是小数的话，那么使用int会报错，需要先转成float。如果要转的话，需要str必须得能够转成int/float，"hello"就不可以

4、对变量进行强制转换，会返回一个数值，但是强制转换后，原变量的空间（值）并不会被影响

## 运算符

//：向下取整，比如4.5，左右有两个整数，取小的部分
**：返回x 的y次幂
/：返回小数，比如10/2 = 5.0
%：取模的公式：a % b = a - a // b * b
	比如-10 % 3

is：两个变量引用对象（指向的数据空间）是否为同一个

### 与或非

and：如果x 为false，返回x，否则返回y
or：如果x 为true，返回x，否则返回y
not：如果x 为true，返回false
又因为0为false，非0为true
总结就是：or左，and右，not取反
**Python在这一部分和其他很多语言都不同**

### 三元运算符

常见的三元运算符：`?:`
Python中使用if - else：max = a if a > b else b
这里有一个题目，是三个数求最大值的

## 标识符的命名与规范

凡是可以自己取名字的地方都是标识符
变量要小写，有多个可以使用下划线；
常量全部大写（不变的，比如PI）
函数名一律小写，多个单词的话用下划线隔开；私有函数双下划线开头
类名使用大驼峰命名，多个单词首字母用大写。

## 键盘输入语句

使用内置函数`input()`
可以使用的情况：name = input("请输入你的名字：")
用户输入之后，会自动赋值到name，之后就可以调用了

而使用input，从控制台接收到的数据类型：str
这个时候如果要对接收到的数据进行运算，需要先类型转换

当然也可以直接在接收到的时候就把数据进行转换了：
age = int(input("输入年龄"))
不过这样就会导致，如果输入的不是数字，就会报错

题目：输入人的年龄，如果大于18，输出xxx
这时候，接受输入默认类型是str，而又**涉及到做判断，所以需要先把接收到的转成整数** 

## 进制

从事计算机行业的，尽量听完，对理解计算机的原理有帮助
且，进制转换是程序员的基本功

> 我记起来了，Java的时候也讲过进制，但我有些忘记了

几进制，就是满几进几，而且这个进制里面看不到这个几

### 二八十六转十进制

二进制转十进制：
规则（需要背）：从最低位右边开始，将每个位上面的数提出来，乘以2的（位数-1）次方，然后求和。
八进制转十进制：
规则：从最低位右边开始，将每个位上面的数提出来，乘以8的（位数-1）次方，然后求和。
十六进制转十进制：
规则：从最低位右边开始，将每个位上面的数提出来，乘以16的（位数-1）次方，然后求和。

### 十进制转二八十六

十进制转二进制：
规则：不断除以2，直到商为0，然后将每部得到的余数倒过来，就是对应的二进制
有内置函数可以使用：bin(数字)
十进制转八进制：
规则：不断除以8，直到商为0，然后将每部得到的余数倒过来，就是对应的二进制
内置函数：oct(数字)
十进制转十六进制：
规则：不断除以16，直到商为0，然后将每部得到的余数倒过来，就是对应的二进制
内置函数：hex(数字)

### 二进制转八六

二进制转八进制：
规则：从低位开始，将二进制数每三位一组，转成对应的八进制即可
	**这里每三位一组，转成八进制，涉及到了2转10（2的几次方）**，然后再转成十六进制
二进制转十六进制：
规则：从低位开始，将二进制数每四位一组，转成对应的十六进制即可
	还有一个快捷方法，1111是15，111是8；
	1111是15的话，1101，就是少了2
	8 4 2 1
	1 1 1 1对应

### 八六转二

八进制转二进制：
规则：八进制数的每一位，转成对应的一个三位的二进制数
	7：111
	3：011
十六转二进制：
规则：十六进制数的每一位，转成对应的一个四位的二进制数
	B：11：10(1:4)11

## 思路分析

**凡是可变化的，都用变量来定义**。
编程最重要的就是思路，自己要知道如何做，才能知道对应的方法是什么

## 位运算

1>>2：1对应的2进制的数字，向右移动两位
~2：2对应的2进制的数字，按位取反是上面

### 1、原码反码补码（计算机组成原理 内容）（重点难点）

1、二进制的最高位是符号位：0表示正数，1表示负数
在此假定用一个字节(8 bit)来表示数字
3 => 0000 0011
-3 => 1000 0011

2、正数的原码、反码、补码都一样（三码合一）
3 => 原码：0000 0011
		反码：0000 0011
		补码：0000 0011

3、负数的反码 = 原码符号位不变，其他位取反
-3 => 原码：1000 0011
		 反码：1111 1100

4、负数的补码 = 反码 + 1；于是负数的反码 = 补码 - 1
-3 => 原码：1000 0011
		 反码：1111 1100
		 补码：1111 1101

5、0的反码、补码都是0

6、**计算机在运算的时候，都是以补码来运算的** （把计算机的加减融合了起来）（**不管是加减，还是位运算，都是要得到补码来运算**）
	1+3 =>
	1 => 补码：0000 0001
	3 => 补码：0000 0011
	1+3 =>		0000 0100 => 补码 ===>原码 0000 0100 => 4
---以上是正数，真正的精髓在负数：
	1-3 =>
1 => 补码：0000 0001
-3 =>原码：1000 0011 => 反码：1111 1100 => 补码：1111 1101（反码+1）
1 - 3 => 1+(-3)
		1的补码：0000 0001
		-3的补码：1111 1101
						  1111 1110（补码） =>反码：1111 1101 =>原码：1000 0100 => -2

7、**运算结果出来之后，依然是补码。但我们要看结果的时候，看原码** 

### 2、位运算

~x：按位取反：
对数据的每个二进制位取反，把1变0，0变1（这里，是都变，包括符号位；而反码的时候，是符号位不变）
**按位取反的时候，也需要根据补码来进行运算** 
位运算的出来的也是补码，依然需要推出来原码是多少（注意先看符号位）

![位运算示例](/images/image-20250912153857336.png)

&：按位与
规则：参与运算的两个值，如果两个相应位(二进制的位)都是1，那么该位的结果是1，否则为0（**注意也要看补码**：计算机不管什么运算，都要以补码的方式进行）

^：按位异或
规则：当两个对应的二进制位相异的时候，那么这一位的结果为1
（**计算的时候，如果是自己手动计算，那么建议在二进制的后面写上补/反/原**）

|：按位或
规则：只要对应的两个二进制位有一个为1，那个位置的结果就是1

<< >>：移位
<< 左移（这里也需要进行**补码**的运算）（**看到计算机、看到数字、看到运算，就想补码**）
规则：运算数的各个二进制位全部左移若干位，由<<右边的数决定移动多少，符号位不变，高位丢弃，低位补零
其实相当于，如果左移一位，相当于对这个数乘以2，再移一位，就又乘以2（左移多少位，相当于乘了多少2）
5<<1：10
->> 右移
除以2，而且取整数，而且是向下取整（取最小的数）
规则：运算数的各个二进制位全部右移若干位，由>>右边的数决定移动多少，符号位不变，低位丢弃，高位补零

## 流程控制

Python中采用缩进来界定代码块，不像其他语言如Java，采用大括号{}来界定

流程控制结束后，是退出控制语句，但并不是退出整个程序

### 多分支

使用if-elif-else的时候，考虑全部情况：
比如成绩在0-100以外的，在以内的才可以考虑到相应的阶段
elif可以有多个，else可以不写

### for循环

基本语法：
for <变量> in <范围/序列>:
	<循环操作语句>

范围/序列：数据集，要处理的数据，这个数据需要是可迭代的对象
Python的for循环是一种轮询机制，对指定的数据集，进行轮训处理

1、把数据集里面的东西取出来，赋给`i`，然后循环。至于`i`会不会在循环体用到，就看需求了
把循环体的内容执行完毕后，还会再回到数据集那里，查看是否还有项，如果有的话，继续

2、如果需要遍历数字序列，可以使用range()函数，该函数生成的数列是**前闭后开** （range(1,5)，会生成1，2，3，4 ）
range(start,stop,step)
	start：默认为0
	stop
	step：步长，默认为1
可以通过list()查看range()生成的序列包含的数据：把range赋值到一个变量，然后使用list(变量名)，打印出来，即可看到相应的数据

3、for还可以和else配合使用：
for <变量> in <序列sequence>:
	<循环语句>
else:
	<循环语句>
使用场景：
当for循环正常遍历结束后，有些逻辑需要处理，就可以使用
至于什么情况下进入到else，是要在for循环正常完成遍历之后，且在遍历过程中**没有被打断**（最常见的情况是遇到`break`语句）

#### 内存分析法

很好用，且很好用。可以多次尝试

![内存分析示意图](/images/image-20250912214116983.png)
nums指向的地址，地址中又有很多地址，指向其他（已经存在的数据)

### while循环

while 判断条件:
	循环体
注意：**如果循环体中，满足判断条件的变量（`i`）不变化，那么就是死循环了** 
`i`：循环变量初始化

注意事项：
while 也可以和 else配合使用
while 判断条件:
	循环体
else:
	循环体
执行场景：在while-else判断条件为false时，会执行else语句块。也就是在遍历过程中，没有被打断(没有执行到break语句)

for循环和while循环的区别：
while是如果一个条件没有false，就会一直执行
但for 是在一个范围区间内进行循环

### 多重循环控制（难点、重点）

如果外层循环是m次，内层循环是n次，那么内层循环实际执行次数是m*n次

如果在`print`语句中，加上`end = ""`表示输出不换行

**for循环，变量不清零？**

### break语句

random模块中randint()函数可以生成随机数，语法为：`random.randint(a,b)` 
意思是返回随机整数N，满足a<=N<=b，相当于range(a,b+1)

循环体中，当判断条件成立，会执行break，之后会**退出当前循环**
1、`break语句用在`**for/while**循环中，会**终结最近的外层循环**
2、如果循环中出现`else`语句，遇到break也会直接跳过该语句
3、如果一个`for`循环被`break`终结，该循环的控制变量会**保持当前值** 

### continue

1、用于`for/while`循环中
2、用于结束本次循环（非终止循环），**继续执行**循环的下一轮次
继续执行的是，该continue最近的外层循环的下一轮次
一旦执行到continue，**当前循环的下面其他代码就不再执行了（结束本次循环），而是直接执行下一轮次的判断条件** 

> 一个是结束本次循环，进行下一次；
> 另一个是退出当前最近的循环，进行下面的语句(?)

### return

跳出函数，**该函数中的所有代码**都不会再去执行
你在哪个地方调用的，就跳到哪个位置（也就是回到调用函数的位置）
如果没有`return`语句的话，默认返回None，通常代表空值的对象

#### 编程思想

1、化繁为简：把复杂需求拆解成简单的需求，一步步完成
把一个较为复杂、较为综合的任务，拆解成简单的任务，本身也是一种能力

2、先死后活：考虑具体需求的时候，先考虑固定的东西，将其实现，然后再考虑活的东西

3、不管题目简单还是复杂，一定要拆解之后再走代码。当你的项目/题目到了一定的量，就可以不用写了

## 学，和习

编程就像游泳一样，仅仅是听到了技巧并无法保证自己真正学会，真正下水的时候，还是会有各种意外
如果只听，但是不练习，是没有任何用的。真正使用到的时候，可能并不单纯是知识点，而是知识线，甚至知识面。
如何精进自己：
1、多听，听懂
2、多思考，用自己的话，把知识点重复一遍
3、多练，练过的题，讲过的题，多练习才能知道**实际的应用场景** 
4、多总结，总结出来之后(其实也就形成自己的知识框架)，再次看到，还可以想到自己是如何学的

## 函数

定义：完成某一功能的程序指令/语句的集合
	某个功能、多条语句
分类：
1、系统函数
	内置函数；模块函数
2、自定义函数
好处：
1、代码复用性、且方便维护
2、将细节封装起来，供其他用户调用

形参：定义的时候指定的；
实参：调用的时候传进去的

函数的思路分析：
1、函数名；2、形参列表；3、函数体
函数定义了，如果不调用，是不会自动执行的
	cry()：就是调用函数

return跳出函数的时候，如果后面有值，可以再赋给其他的变量，当然也可以直接返回。

### 调用函数

程序员调用函数，就像下达任务一样，这时候会有一些参数传入。然后函数返回结果

![函数调用栈示意图](/images/image-20250913153731909.png)
代码执行的时候会开辟新的栈，一般成为主栈。栈和栈之间是独立的空间。主栈意味着代码开始执行。
编译器每遇到一个函数，就会开辟一个新栈（新栈可以理解为是一个独立的空间)
一旦执行某一个函数，就会进入到对应的函数代码，把实参传给相应的形参
数据区，是存放数据的，放值的。
return表示跳出函数，如果后面有值的话，会把值返回，**在哪个地方调用的，就返回到哪里**
整个程序执行完毕后，开辟的数据区、代码区、栈区都会被回收

### 注意事项

1、函数中的变量是局部的，函数外不生效
2、两个函数名相同的函数，在同一个文件，调用的时候遵循就近原则（其它语言中会报错，但是Python语言中允许两个同名函数）
	Python中没有函数重载（Java中有）：根据参数不同，调用不同
3、传参的时候，有一种是位置传参。其中定义的**形参，不用指定数据类型，会根据传入的实参来决定** 
4、函数允许返回多个值，返回的数据类型不受限制
5、函数支持关键字参数，也就是：函数调用的时候，可以通过"形参名=实参值"的形式传递参数。可以不受上面(位置传参)的限制
	（在传递实参中）price = 90

6、函数支持默认参数(缺省函数)：定义函数时，可以给参数提供默认值，调用时，如果提供了指定的值，就用指定的，如果没有，就用默认的。默认值写在形参等号后，且有默认值的要在最后放着

7、函数支持可变参数(不定长参数)：
	应用场景：调用函数的时候，不确定传入多少个实参。比如求多个数的和
	传入的多个实参，会被组成一个元组(tuple)（元组就是可以储存多个数据项的）
	具体使用：**(星号*)通常表示[0到多]** `def sum(*args)`

8、函数的可变参数，还支持多个关键字函数，也就是说支持"参数名=实参值"的形式
	关键字函数：`price=90`(实参中)
	应用场景：调用函数时，不确定传入多少个关键字参数的情况
	传入的多个关键字参数，会组成一个字典(dict)（字典可以储存多个`键=值`的数据项）
	具体使用：`def 函数名(**args)`：一个星是多个未知的参数，现在是关键字可变参数

9、Python可以调用另一个.py文件中的函数
	想在f2.py文件中调用f1.py的函数，可以先导入，然后再用文件名.函数名即可（这个文件其实就是模块，Python中，一个文件就是一个模块）
	import f1
	f1.add(实参)

以上这些没有什么编程思想的东西，你自己看书的时候，一直在记这些……所以某种程度上，还是有个老师好啊

### 传参机制

#### 字符串和数值类型的传参机制

1、数值类型传参机制：

> 调用函数会开一个新栈；函数调用完毕会返回原来开始调用的地方

![数值类型传参机制](/images/image-20250913184155106.png)
函数内`a`的加减，并不影响函数外的`a` 
而且不管是数值，还是字符串，都会存在驻留机制，所以在参数刚传入进函数的时候，函数外的`a`和内的`a`指向都是一样的

2、字符串类型传参机制

![字符串类型传参机制](/images/image-20250913184632633.png)

3、结论：

字符串和数值类型是不可变数据类型：当对应的变量的值发生了变化，它对应的内存地址也会发生改变
可变数据类型：指向的空间没有变，地址没有变，但是里面的数据改变了；
不可变数据类型：指向的空间改变，地址改变。

### 递归调用(recursion)

传参机制和调用机制是理解递归调用的基础。
各种算法中也会使用到递归。

先把机制理解了，才可能有后续更复杂的代码
