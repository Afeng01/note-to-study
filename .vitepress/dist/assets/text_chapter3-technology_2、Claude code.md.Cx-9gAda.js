import{_ as a,c as e,o as d,ag as o}from"./chunks/framework.CbEZKkNm.js";const s=JSON.parse('{"title":"AI 编程和Claude code","description":"","frontmatter":{},"headers":[],"relativePath":"text/chapter3-technology/2、Claude code.md","filePath":"text/chapter3-technology/2、Claude code.md"}'),r={name:"text/chapter3-technology/2、Claude code.md"};function c(l,t,n,i,h,p){return d(),e("div",null,t[0]||(t[0]=[o('<h1 id="ai-编程和claude-code" tabindex="-1">AI 编程和Claude code <a class="header-anchor" href="#ai-编程和claude-code" aria-label="Permalink to &quot;AI 编程和Claude code&quot;">​</a></h1><h2 id="ai-编程" tabindex="-1">AI 编程 <a class="header-anchor" href="#ai-编程" aria-label="Permalink to &quot;AI 编程&quot;">​</a></h2><p>1、软件开发不再是“一个人手写代码到天亮”，而是人类负责想法 + AI负责生成 2、未来大部分岗位（包括非程序员）都会用到“AI 辅助编程”做自动化和数据处理 3、不会 AI 编程的人，未来用工具的效率会比别人低几个量级 4、会 AI 编程的人，不仅可以自己做，还可以快速验证想法和做副业产品</p><p>（存疑，<strong>可能基础技能还是需要掌握的，可以参考中间件的文稿</strong>）</p><h2 id="claude-code-角色定位" tabindex="-1">Claude code 角色定位 <a class="header-anchor" href="#claude-code-角色定位" aria-label="Permalink to &quot;Claude code 角色定位&quot;">​</a></h2><p>本质上是个Web开发时代的编程助手，最适合基于Web技术栈和跨平台技术的开发</p><p>但是并不适合：大型系统架构</p><p>Claude Code这个工具最擅长的还是web相关的开发。 本质上的原因Claude Code 生成的代码，本质上依赖于开放、通用、跨平台的运行环境。 因为，Web 技术（HTML/CSS/JavaScript）符合这三个条件 JavaScript 是浏览器的唯一原生脚本语言，几乎任何电脑、手机都有浏览器 Claude Code 在训练中大量接触到开源前端/后端的代码样本（JavaScript、Python），而这些生态文档和示例都公开且容易被学习到。 所以说，生成的结果只要用户有浏览器，就能运行，不依赖复杂的本地配置（不像 C++、Java 桌面应用那样需要繁琐的环境）</p><h2 id="其他内容" tabindex="-1">其他内容 <a class="header-anchor" href="#其他内容" aria-label="Permalink to &quot;其他内容&quot;">​</a></h2><h3 id="agentic-工作流" tabindex="-1">Agentic 工作流 <a class="header-anchor" href="#agentic-工作流" aria-label="Permalink to &quot;Agentic 工作流&quot;">​</a></h3><p>Agentic 工作流（Agentic Workflow）是指由自主智能体（Agent）驱动的工作流程，它能够：自主理解任务（思考）、制定解决方案（计划）、按计划执行并调整（执行）、在必要时循环迭代（反思） Claude Code、ChatGPT、AutoGPT、LangChain 等 AI 工具，都可以扮演 Agentic 工作流中的“智能体”角色。</p><p>AI Agent“思考-计划-执行”的工作模式</p><table tabindex="0"><thead><tr><th>阶段</th><th>核心问题</th><th>AI 在做</th><th>产出</th></tr></thead><tbody><tr><td>思考</td><td>“我要解决的是什么问题？”</td><td>解析任务，理解上下文，分析需求</td><td>问题定义、假设</td></tr><tr><td>计划</td><td>“我应该按什么步骤来做？”</td><td>拆分任务、制定顺序、选择方法</td><td>行动计划、任务列表</td></tr><tr><td>执行</td><td>我该具体怎么做？</td><td>按计划执行步骤，生成结果，必要时修正</td><td>可用结果或下一步输入</td></tr></tbody></table><h3 id="上下文协议" tabindex="-1">上下文协议 <a class="header-anchor" href="#上下文协议" aria-label="Permalink to &quot;上下文协议&quot;">​</a></h3><p>需要一种机制，把<strong>项目的信息、环境信息</strong>整理好，每次交给模型。这个机制，就叫 上下文协议（Context Protocol）。</p><p>作用：</p><p>防止模型“断片”：没有上下文协议，模型会忘记之前你建了什么文件、用的是什么框架。 减少重复沟通：你不用每次都把项目结构解释一遍。 提高准确性：模型生成的代码会贴合你当前项目，而不是给你一个通用但错误的版本。</p><p>上下文协议的价值之一就是如何在有限的窗口里组织最关键的信息，避免无关内容挤占空间。</p><p>上下文协议的“动态更新” 不是一次性“给一堆信息”，而是会 随任务过程不断刷新。比如你刚刚新建了一个 login.py，协议会立刻更新，让模型知道多了这个文件。这也是为什么它能保证对话的连续性。</p><p>cc常用指令，以及高效方式</p><p>1/自动扫描，你自己想到的，肯定会有人提前解决了</p><p>2/文件→文件夹，工作流，typora，</p><p>3/重复的地方，使用编程快捷替换</p>',23)]))}const C=a(r,[["render",c]]);export{s as __pageData,C as default};
