import{_ as t,c as a,o,ag as p}from"./chunks/framework.CbEZKkNm.js";const u=JSON.parse('{"title":"Hog","description":"","frontmatter":{},"headers":[],"relativePath":"text/chapter6-code/2、higher-order functions.md","filePath":"text/chapter6-code/2、higher-order functions.md"}'),r={name:"text/chapter6-code/2、higher-order functions.md"};function n(s,e,i,c,d,h){return o(),a("div",null,e[0]||(e[0]=[p('<h2 id="_1-6-高阶函数" tabindex="-1">1.6 高阶函数 <a class="header-anchor" href="#_1-6-高阶函数" aria-label="Permalink to &quot;1.6 高阶函数&quot;">​</a></h2><p>函数就是一种抽象方法，它的参数并不是特定的内容，可以是数字，也可以是传入的其他函数(可行的) 一般来说，如果没有函数/缺少函数定义，那么我们的工作会在特定的原始操作级别(比如乘法)，而不会是在更高的操作级别</p><p>我们对强大的编程语言提出的要求之一就是能够<strong>通过将名称分配给通用模板/模式（general patterns）来构建抽象，然后直接使用该名称进行工作</strong>。 参考高阶函数的第二例子 给通用模板赋予名称，然后复用。 代码中重复出现了一些常见的编程模板，但它们可以与许多不同的函数一起使用 (把常见的抽象出来成为函数，然后再和不同的函数结合使用) 这些模板也可以通过给它们命名来进行抽象(就是上面括号说的那样)（这部分没懂）</p><p>为了将某些通用模板表达为具名概念（named concepts），我们需要构造一种“可以<strong>接收其他函数作为参数</strong>”或“可以<strong>把函数当作返回值</strong>”的函数。这种可以操作函数的函数就叫做高阶函数（higher-order functions）</p><h3 id="_1-6-1-作为参数的函数" tabindex="-1">1.6.1 作为参数的函数 <a class="header-anchor" href="#_1-6-1-作为参数的函数" aria-label="Permalink to &quot;1.6.1 作为参数的函数&quot;">​</a></h3><p>模板(pattern)，也就是通用的部分</p><p>多个函数如果操作逻辑似乎是一样的，那么可以提炼出来一个通用的模板，把固定会出现的内容放进来，然后会变化的内容再单独弄一个函数，比如<code>&lt;term&gt;</code>。（这种单独弄函数的就是槽位-slots，后续可以转化成形参） term，可以作为引入的任意函数项，在参数中它只是一个名字。如果这个参数项是一个函数的话，在实际使用中，就需要传入一个参数给到这个函数，以便函数可以正常运行 作为程序设计者，当然希望语言足够强大，以便可以编写一个表达&quot;求和&quot;概念的函数，而不是仅仅计算一个特定和的函数。</p><p>一旦开始重复，那么就可以考虑，是否可以提取出来更强大的概括/模型了。 而定义了一个抽象的函数，是需要在不这么抽象的地方使用抽象的函数。也就是要在表面使用更底层的</p><blockquote><p>高阶函数，是否也就是泛化？</p></blockquote><p>而既然设计了高阶函数（泛化），也就需要将各自不同的地方提取出来，弄成单独的函数，以便成为&quot;作为参数的函数&quot;</p><p><strong>两个看起来类似的函数，可以提炼抽象出高阶函数，但同时需要有各自的部分，也弄出来。于是原来的两个函数就可以简化很多了</strong>。</p><p>term：项，函数项</p><p>基本能够理解，相同的函数中抽象出来一个共同的方法（模板），然后各自的部分弄一个，原函数就可以直接缩减很多部分了</p><h3 id="_1-6-2-作为通用方法的函数" tabindex="-1">1.6.2 作为通用方法的函数 <a class="header-anchor" href="#_1-6-2-作为通用方法的函数" aria-label="Permalink to &quot;1.6.2 作为通用方法的函数&quot;">​</a></h3><h3 id="作为返回值的函数-局部定义函数" tabindex="-1">作为返回值的函数（局部定义函数） <a class="header-anchor" href="#作为返回值的函数-局部定义函数" aria-label="Permalink to &quot;作为返回值的函数（局部定义函数）&quot;">​</a></h3><p>作为返回值的函数，他可能只会返回一个数字，但有趣的是，定义在函数里面的函数，可以调用外部函数的形参和自身的形参（类似Java的部分）</p><p>&quot;当一个函数定义在另一个函数体内部，并且创建的函数绑定到局部帧中的一个名称&quot;</p><p>图片中，运算符是任何计算结果为函数的表达式；操作数是可以计算为任何值的表达式 <strong>这里最后一部分没看懂，比如make_adder那里</strong></p><p>高阶函数：将另一个函数作为参数，或者返回一个函数 特点：可以不用重复；将关注点分离到不同的函数中（？），让每个函数只完成一个工作</p><h3 id="_1-6-3-定义函数iii-嵌套定义" tabindex="-1">1.6.3 定义函数Ⅲ 嵌套定义 <a class="header-anchor" href="#_1-6-3-定义函数iii-嵌套定义" aria-label="Permalink to &quot;1.6.3 定义函数Ⅲ 嵌套定义&quot;">​</a></h3><h1 id="hog" tabindex="-1">Hog <a class="header-anchor" href="#hog" aria-label="Permalink to &quot;Hog&quot;">​</a></h1><p>在整个项目中，您应该测试代码的正确性。经常测试是一个好习惯，这样可以很容易地隔离任何问题。但是，您不应该过于频繁地测试，以便让自己有时间思考问题。</p><p><code>ok</code> 的主要目的是测试您的实现。 如果您想以交互方式测试您的代码，您可以运行:</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> python3 ok -q [问题编号] -i</span></span></code></pre></div><p>使用相应的问题编号（例如 <code>01</code>）运行。这将运行该问题的测试，直到遇到第一个失败的测试为止，然后您将有机会以交互方式测试您编写的函数。</p><p>您还可以通过输入以下代码，在 OK 中使用调试打印功能：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span> print(&quot;DEBUG:&quot;, x)</span></span></code></pre></div><p>这会在终端中生成输出，且不会因多余输出而导致 OK 测试失败。</p><p>完成问题5 - play函数之后，可以运行GUI：</p><p>python3 hog_gui.py</p><p>第一阶段，开发 Hog 游戏的模拟器：</p><p>有问题可以启用调试功能：</p>',32)]))}const g=t(r,[["render",n]]);export{u as __pageData,g as default};
