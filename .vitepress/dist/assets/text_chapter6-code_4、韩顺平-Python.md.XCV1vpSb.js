import{_ as e,c as t,o,ag as r}from"./chunks/framework.CbEZKkNm.js";const n="/note-to-study/images/image-20250912093008979.png",i="/note-to-study/images/image-20250912103934336.png",h="/note-to-study/images/image-20250912153857336.png",l="/note-to-study/images/image-20250912214116983.png",p="/note-to-study/images/image-20250913153731909.png",s="/note-to-study/images/image-20250913184155106.png",d="/note-to-study/images/image-20250913184632633.png",x=JSON.parse('{"title":"韩顺平 - Python 笔记记录","description":"","frontmatter":{},"headers":[],"relativePath":"text/chapter6-code/4、韩顺平-Python.md","filePath":"text/chapter6-code/4、韩顺平-Python.md"}'),c={name:"text/chapter6-code/4、韩顺平-Python.md"};function u(q,a,g,b,f,m){return o(),t("div",null,a[0]||(a[0]=[r('<h1 id="韩顺平-python-笔记记录" tabindex="-1">韩顺平 - Python 笔记记录 <a class="header-anchor" href="#韩顺平-python-笔记记录" aria-label="Permalink to &quot;韩顺平 - Python 笔记记录&quot;">​</a></h1><h2 id="结合实际工作-快速掌握语言技术的方法" tabindex="-1">结合实际工作，快速掌握语言技术的方法 <a class="header-anchor" href="#结合实际工作-快速掌握语言技术的方法" aria-label="Permalink to &quot;结合实际工作，快速掌握语言技术的方法&quot;">​</a></h2><p>1、学语言，总是有一个需求的（工作需求/跳槽需求/技术控） 2、需求产生后，先看看使用现有技术是否可以解决（思考完之后，会有一种强烈的学习技术的必要性） 2.1、可以解决，但不够完美；2.2、不能解决 3、引出要学习的技术/知识点 4、先学习新技术知识点的基本原理和基本语法（这个时候不要考虑细节） 5、了解了之后，快速入门，完成基本程序，完成CRUD 5.1、比如说mysql先写一个基本的增删改查；可以有一个整体的感觉；首先<em>能跑就行</em> 6、开始研究技术的注意事项、使用细节、使用规范、如何优化 6.1、这个部分没有止境，可以不断提升。这就是程序员之间的差距，他们看到的东西不一样 初级程序员可能只能看到1、2点，高级程序员可以看到6、7点</p><h2 id="快捷键" tabindex="-1">快捷键 <a class="header-anchor" href="#快捷键" aria-label="Permalink to &quot;快捷键&quot;">​</a></h2><p>ctrl + d：复制当前行 shift + delete：删除当前行 格式化代码：ctrl + alt + l alt + r：快速运行程序 ctrl + h：查看类的层级关系 ctrl + r：替换</p><h2 id="转义字符" tabindex="-1">转义字符 <a class="header-anchor" href="#转义字符" aria-label="Permalink to &quot;转义字符&quot;">​</a></h2><p>\\t：制表位 \\n：换行符 \\ \\ ：输出斜杠 \\ &quot; ：输出引号 \\r：回车，覆盖当前行的前面内容 这部分需要在引号里面引起来</p><h2 id="注释-的一个小细节" tabindex="-1">注释 的一个小细节 <a class="header-anchor" href="#注释-的一个小细节" aria-label="Permalink to &quot;注释 的一个小细节&quot;">​</a></h2><p>在文件开头加上 #coding:编码 既可用来指定文件的类型</p><h2 id="文档的查看和使用" tabindex="-1">文档的查看和使用 <a class="header-anchor" href="#文档的查看和使用" aria-label="Permalink to &quot;文档的查看和使用&quot;">​</a></h2><h2 id="计算机内存" tabindex="-1">计算机内存 <a class="header-anchor" href="#计算机内存" aria-label="Permalink to &quot;计算机内存&quot;">​</a></h2><p>计算机中所有的程序运行都在内存中进行： 代码→加载到内存→执行 知识→加载到记忆/大脑→执行</p><p>关于这部分的东西，是计算机组成原理的课程</p><p><img src="'+n+'" alt="image-20250912093008979"></p><h2 id="格式化输出" tabindex="-1">格式化输出 <a class="header-anchor" href="#格式化输出" aria-label="Permalink to &quot;格式化输出&quot;">​</a></h2><p>1、%操作符输出：</p><p>age = 80 score = 77.5 gender = &quot;男&quot; name = &quot;贾宝玉&quot; print(&quot;个人信息： %s %d %s %.2f&quot; % (name ,age ,gender, score))</p><p>%s等内容就是占位符，s 是字符串，d是整数型，.2f是浮点数，后面有几个小数 中间的间隔（%s和%d），可以自己定义</p><p>2、format() 函数：</p><p>print(&quot;个人信息：{} {} {}&quot;.format(填充具体内容) ) 后面format的内容，少了不可以，但是多了可以不报错</p><p>3、f-strings：（推荐）</p><p>print(f&quot;个人信息：{name} {age} {gender} {score}&quot;) 加了 f ，含义会发生变化 就可以直接在引号里面使用大括号，然后对应具体的变量 <strong>这个可以常用</strong></p><h2 id="加号的使用" tabindex="-1">加号的使用 <a class="header-anchor" href="#加号的使用" aria-label="Permalink to &quot;加号的使用&quot;">​</a></h2><p>左右两边都是数值型（小数、整数），就是加法运算 左右两边都是字符串，拼接运算</p><h2 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-label="Permalink to &quot;数据类型&quot;">​</a></h2><p>a是变量，变量本身是没有类型的，他可以随意更改指向的内容 但是a变量指向的数据，是有类型的</p><p>可以通过type()函数查看数据类型（本质是查看变量指向的数据类型）</p><h3 id="进制" tabindex="-1">进制 <a class="header-anchor" href="#进制" aria-label="Permalink to &quot;进制&quot;">​</a></h3><p>十六进制：前缀0x，由0-9和A-F组合 八进制：0o，由0-7组合 二进制：0b，由0 1组合</p><h3 id="字节" tabindex="-1">字节 <a class="header-anchor" href="#字节" aria-label="Permalink to &quot;字节&quot;">​</a></h3><p>编程中，存储数据的基本单位是字节（byte） 1 byte = 8 bit（位）</p><h3 id="科学计数法" tabindex="-1">科学计数法 <a class="header-anchor" href="#科学计数法" aria-label="Permalink to &quot;科学计数法&quot;">​</a></h3><p>5.12e2：5.12乘以10的二次方 5.12E-2：5.12除以10的二次方</p><h3 id="浮点数精度损失问题" tabindex="-1">浮点数精度损失问题 <a class="header-anchor" href="#浮点数精度损失问题" aria-label="Permalink to &quot;浮点数精度损失问题&quot;">​</a></h3><p>可以使用Decimal 类进行精确计算 先进行导入，然后再使用</p><h3 id="布尔值数值" tabindex="-1">布尔值数值 <a class="header-anchor" href="#布尔值数值" aria-label="Permalink to &quot;布尔值数值&quot;">​</a></h3><p>1、Python会将true视为1，将false视为0 于是print(true + 10) #结果就是11</p><p>2、Python中，非0被视为真值，0被视为假值 if 0: print #不输出 if -1: #输出 if &quot;字符串也可以&quot;</p><h3 id="字符串使用" tabindex="-1">字符串使用 <a class="header-anchor" href="#字符串使用" aria-label="Permalink to &quot;字符串使用&quot;">​</a></h3><p>&quot;jack说&#39;我在这里&#39; &quot; 变量名 = &quot;&quot;&quot;中间可以放复杂的内容&quot;&quot;&quot;</p><p>如果使用转义字符的话，不想这个转义字符被使用，就可以在字符串前面加上一个r，即可</p><h2 id="扩展知识" tabindex="-1">扩展知识 <a class="header-anchor" href="#扩展知识" aria-label="Permalink to &quot;扩展知识&quot;">​</a></h2><p>有点难，掌握了肯定是对后面理解知识有帮助的；但如果没有掌握，也没有关系，对后面影响微乎其微</p><h3 id="驻留机制" tabindex="-1">驻留机制 <a class="header-anchor" href="#驻留机制" aria-label="Permalink to &quot;驻留机制&quot;">​</a></h3><p>内存中区分空间，是靠地址来的</p><p><img src="'+i+'" alt="内存地址示意图"> 不同的变量名(指针)都指向同一个空间</p><p>驻留机制的几种情况： 1、字符串是由26个英文字母大小写、0-9、_组成的时候 2、字符串长度为0或1时 3、字符串在编译时进行驻留（运行之前就已经知道是什么了），运行时不驻留 4、[-5，256]之间的整数数字 有时候会有意外情况，是pycharm进行了优化</p><p>如果想要在命令行窗口强制一样，可以使用sys.intern()</p><h2 id="数据类型转换" tabindex="-1">数据类型转换 <a class="header-anchor" href="#数据类型转换" aria-label="Permalink to &quot;数据类型转换&quot;">​</a></h2><h3 id="隐式类型转换" tabindex="-1">隐式类型转换 <a class="header-anchor" href="#隐式类型转换" aria-label="Permalink to &quot;隐式类型转换&quot;">​</a></h3><p>Python变量的类型不固定，会根据变量当前值在运行时候进行决定 这期间可以通过type()函数进行查看。也叫自动转换</p><p>在进行运算的时候，数据类型会向高精度自动转换 比如int和float相加，精度会变成float</p><h3 id="显式类型转换" tabindex="-1">显式类型转换 <a class="header-anchor" href="#显式类型转换" aria-label="Permalink to &quot;显式类型转换&quot;">​</a></h3><p>i = 10 j = float(i) 主动进行转换</p><h4 id="注意事项" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项&quot;">​</a></h4><p>1、不管什么值的int、float都可以转成str，str(x)将对象x转成字符串 在Python中，一切皆为对象</p><p>2、int和float互转的时候，精度会有所变化</p><p>3、str转int、float的时候，使用int(x)等，可以转成。但是如果str是小数的话，那么使用int会报错，需要先转成float。如果要转的话，需要str必须得能够转成int/float，&quot;hello&quot;就不可以</p><p>4、对变量进行强制转换，会返回一个数值，但是强制转换后，原变量的空间（值）并不会被影响</p><h2 id="运算符" tabindex="-1">运算符 <a class="header-anchor" href="#运算符" aria-label="Permalink to &quot;运算符&quot;">​</a></h2><p>//：向下取整，比如4.5，左右有两个整数，取小的部分 **：返回x 的y次幂 /：返回小数，比如10/2 = 5.0 %：取模的公式：a % b = a - a // b * b 比如-10 % 3</p><p>is：两个变量引用对象（指向的数据空间）是否为同一个</p><h3 id="与或非" tabindex="-1">与或非 <a class="header-anchor" href="#与或非" aria-label="Permalink to &quot;与或非&quot;">​</a></h3><p>and：如果x 为false，返回x，否则返回y or：如果x 为true，返回x，否则返回y not：如果x 为true，返回false 又因为0为false，非0为true 总结就是：or左，and右，not取反 <strong>Python在这一部分和其他很多语言都不同</strong></p><h3 id="三元运算符" tabindex="-1">三元运算符 <a class="header-anchor" href="#三元运算符" aria-label="Permalink to &quot;三元运算符&quot;">​</a></h3><p>常见的三元运算符：<code>?:</code> Python中使用if - else：max = a if a &gt; b else b 这里有一个题目，是三个数求最大值的</p><h2 id="标识符的命名与规范" tabindex="-1">标识符的命名与规范 <a class="header-anchor" href="#标识符的命名与规范" aria-label="Permalink to &quot;标识符的命名与规范&quot;">​</a></h2><p>凡是可以自己取名字的地方都是标识符 变量要小写，有多个可以使用下划线； 常量全部大写（不变的，比如PI） 函数名一律小写，多个单词的话用下划线隔开；私有函数双下划线开头 类名使用大驼峰命名，多个单词首字母用大写。</p><h2 id="键盘输入语句" tabindex="-1">键盘输入语句 <a class="header-anchor" href="#键盘输入语句" aria-label="Permalink to &quot;键盘输入语句&quot;">​</a></h2><p>使用内置函数<code>input()</code> 可以使用的情况：name = input(&quot;请输入你的名字：&quot;) 用户输入之后，会自动赋值到name，之后就可以调用了</p><p>而使用input，从控制台接收到的数据类型：str 这个时候如果要对接收到的数据进行运算，需要先类型转换</p><p>当然也可以直接在接收到的时候就把数据进行转换了： age = int(input(&quot;输入年龄&quot;)) 不过这样就会导致，如果输入的不是数字，就会报错</p><p>题目：输入人的年龄，如果大于18，输出xxx 这时候，接受输入默认类型是str，而又<strong>涉及到做判断，所以需要先把接收到的转成整数</strong></p><h2 id="进制-1" tabindex="-1">进制 <a class="header-anchor" href="#进制-1" aria-label="Permalink to &quot;进制&quot;">​</a></h2><p>从事计算机行业的，尽量听完，对理解计算机的原理有帮助 且，进制转换是程序员的基本功</p><blockquote><p>我记起来了，Java的时候也讲过进制，但我有些忘记了</p></blockquote><p>几进制，就是满几进几，而且这个进制里面看不到这个几</p><h3 id="二八十六转十进制" tabindex="-1">二八十六转十进制 <a class="header-anchor" href="#二八十六转十进制" aria-label="Permalink to &quot;二八十六转十进制&quot;">​</a></h3><p>二进制转十进制： 规则（需要背）：从最低位右边开始，将每个位上面的数提出来，乘以2的（位数-1）次方，然后求和。 八进制转十进制： 规则：从最低位右边开始，将每个位上面的数提出来，乘以8的（位数-1）次方，然后求和。 十六进制转十进制： 规则：从最低位右边开始，将每个位上面的数提出来，乘以16的（位数-1）次方，然后求和。</p><h3 id="十进制转二八十六" tabindex="-1">十进制转二八十六 <a class="header-anchor" href="#十进制转二八十六" aria-label="Permalink to &quot;十进制转二八十六&quot;">​</a></h3><p>十进制转二进制： 规则：不断除以2，直到商为0，然后将每部得到的余数倒过来，就是对应的二进制 有内置函数可以使用：bin(数字) 十进制转八进制： 规则：不断除以8，直到商为0，然后将每部得到的余数倒过来，就是对应的二进制 内置函数：oct(数字) 十进制转十六进制： 规则：不断除以16，直到商为0，然后将每部得到的余数倒过来，就是对应的二进制 内置函数：hex(数字)</p><h3 id="二进制转八六" tabindex="-1">二进制转八六 <a class="header-anchor" href="#二进制转八六" aria-label="Permalink to &quot;二进制转八六&quot;">​</a></h3><p>二进制转八进制： 规则：从低位开始，将二进制数每三位一组，转成对应的八进制即可 <strong>这里每三位一组，转成八进制，涉及到了2转10（2的几次方）</strong>，然后再转成十六进制 二进制转十六进制： 规则：从低位开始，将二进制数每四位一组，转成对应的十六进制即可 还有一个快捷方法，1111是15，111是8； 1111是15的话，1101，就是少了2 8 4 2 1 1 1 1 1对应</p><h3 id="八六转二" tabindex="-1">八六转二 <a class="header-anchor" href="#八六转二" aria-label="Permalink to &quot;八六转二&quot;">​</a></h3><p>八进制转二进制： 规则：八进制数的每一位，转成对应的一个三位的二进制数 7：111 3：011 十六转二进制： 规则：十六进制数的每一位，转成对应的一个四位的二进制数 B：11：10(1:4)11</p><h2 id="思路分析" tabindex="-1">思路分析 <a class="header-anchor" href="#思路分析" aria-label="Permalink to &quot;思路分析&quot;">​</a></h2><p><strong>凡是可变化的，都用变量来定义</strong>。 编程最重要的就是思路，自己要知道如何做，才能知道对应的方法是什么</p><h2 id="位运算" tabindex="-1">位运算 <a class="header-anchor" href="#位运算" aria-label="Permalink to &quot;位运算&quot;">​</a></h2><p>1&gt;&gt;2：1对应的2进制的数字，向右移动两位 ~2：2对应的2进制的数字，按位取反是上面</p><h3 id="_1、原码反码补码-计算机组成原理-内容-重点难点" tabindex="-1">1、原码反码补码（计算机组成原理 内容）（重点难点） <a class="header-anchor" href="#_1、原码反码补码-计算机组成原理-内容-重点难点" aria-label="Permalink to &quot;1、原码反码补码（计算机组成原理 内容）（重点难点）&quot;">​</a></h3><p>1、二进制的最高位是符号位：0表示正数，1表示负数 在此假定用一个字节(8 bit)来表示数字 3 =&gt; 0000 0011 -3 =&gt; 1000 0011</p><p>2、正数的原码、反码、补码都一样（三码合一） 3 =&gt; 原码：0000 0011 反码：0000 0011 补码：0000 0011</p><p>3、负数的反码 = 原码符号位不变，其他位取反 -3 =&gt; 原码：1000 0011 反码：1111 1100</p><p>4、负数的补码 = 反码 + 1；于是负数的反码 = 补码 - 1 -3 =&gt; 原码：1000 0011 反码：1111 1100 补码：1111 1101</p><p>5、0的反码、补码都是0</p><p>6、<strong>计算机在运算的时候，都是以补码来运算的</strong> （把计算机的加减融合了起来）（<strong>不管是加减，还是位运算，都是要得到补码来运算</strong>） 1+3 =&gt; 1 =&gt; 补码：0000 0001 3 =&gt; 补码：0000 0011 1+3 =&gt; 0000 0100 =&gt; 补码 ===&gt;原码 0000 0100 =&gt; 4 ---以上是正数，真正的精髓在负数： 1-3 =&gt; 1 =&gt; 补码：0000 0001 -3 =&gt;原码：1000 0011 =&gt; 反码：1111 1100 =&gt; 补码：1111 1101（反码+1） 1 - 3 =&gt; 1+(-3) 1的补码：0000 0001 -3的补码：1111 1101 1111 1110（补码） =&gt;反码：1111 1101 =&gt;原码：1000 0100 =&gt; -2</p><p>7、<strong>运算结果出来之后，依然是补码。但我们要看结果的时候，看原码</strong></p><h3 id="_2、位运算" tabindex="-1">2、位运算 <a class="header-anchor" href="#_2、位运算" aria-label="Permalink to &quot;2、位运算&quot;">​</a></h3><p>~x：按位取反： 对数据的每个二进制位取反，把1变0，0变1（这里，是都变，包括符号位；而反码的时候，是符号位不变） <strong>按位取反的时候，也需要根据补码来进行运算</strong> 位运算的出来的也是补码，依然需要推出来原码是多少（注意先看符号位）</p><p><img src="'+h+'" alt="位运算示例"></p><p>&amp;：按位与 规则：参与运算的两个值，如果两个相应位(二进制的位)都是1，那么该位的结果是1，否则为0（<strong>注意也要看补码</strong>：计算机不管什么运算，都要以补码的方式进行）</p><p>^：按位异或 规则：当两个对应的二进制位相异的时候，那么这一位的结果为1 （<strong>计算的时候，如果是自己手动计算，那么建议在二进制的后面写上补/反/原</strong>）</p><p>|：按位或 规则：只要对应的两个二进制位有一个为1，那个位置的结果就是1</p><p>&lt;&lt; &gt;&gt;：移位 &lt;&lt; 左移（这里也需要进行<strong>补码</strong>的运算）（<strong>看到计算机、看到数字、看到运算，就想补码</strong>） 规则：运算数的各个二进制位全部左移若干位，由&lt;&lt;右边的数决定移动多少，符号位不变，高位丢弃，低位补零 其实相当于，如果左移一位，相当于对这个数乘以2，再移一位，就又乘以2（左移多少位，相当于乘了多少2） 5&lt;&lt;1：10 -&gt;&gt; 右移 除以2，而且取整数，而且是向下取整（取最小的数） 规则：运算数的各个二进制位全部右移若干位，由&gt;&gt;右边的数决定移动多少，符号位不变，低位丢弃，高位补零</p><h2 id="流程控制" tabindex="-1">流程控制 <a class="header-anchor" href="#流程控制" aria-label="Permalink to &quot;流程控制&quot;">​</a></h2><p>Python中采用缩进来界定代码块，不像其他语言如Java，采用大括号{}来界定</p><p>流程控制结束后，是退出控制语句，但并不是退出整个程序</p><h3 id="多分支" tabindex="-1">多分支 <a class="header-anchor" href="#多分支" aria-label="Permalink to &quot;多分支&quot;">​</a></h3><p>使用if-elif-else的时候，考虑全部情况： 比如成绩在0-100以外的，在以内的才可以考虑到相应的阶段 elif可以有多个，else可以不写</p><h3 id="for循环" tabindex="-1">for循环 <a class="header-anchor" href="#for循环" aria-label="Permalink to &quot;for循环&quot;">​</a></h3><p>基本语法： for &lt;变量&gt; in &lt;范围/序列&gt;: &lt;循环操作语句&gt;</p><p>范围/序列：数据集，要处理的数据，这个数据需要是可迭代的对象 Python的for循环是一种轮询机制，对指定的数据集，进行轮训处理</p><p>1、把数据集里面的东西取出来，赋给<code>i</code>，然后循环。至于<code>i</code>会不会在循环体用到，就看需求了 把循环体的内容执行完毕后，还会再回到数据集那里，查看是否还有项，如果有的话，继续</p><p>2、如果需要遍历数字序列，可以使用range()函数，该函数生成的数列是<strong>前闭后开</strong> （range(1,5)，会生成1，2，3，4 ） range(start,stop,step) start：默认为0 stop step：步长，默认为1 可以通过list()查看range()生成的序列包含的数据：把range赋值到一个变量，然后使用list(变量名)，打印出来，即可看到相应的数据</p><p>3、for还可以和else配合使用： for &lt;变量&gt; in &lt;序列sequence&gt;: &lt;循环语句&gt; else: &lt;循环语句&gt; 使用场景： 当for循环正常遍历结束后，有些逻辑需要处理，就可以使用 至于什么情况下进入到else，是要在for循环正常完成遍历之后，且在遍历过程中<strong>没有被打断</strong>（最常见的情况是遇到<code>break</code>语句）</p><h4 id="内存分析法" tabindex="-1">内存分析法 <a class="header-anchor" href="#内存分析法" aria-label="Permalink to &quot;内存分析法&quot;">​</a></h4><p>很好用，且很好用。可以多次尝试</p><p><img src="'+l+'" alt="内存分析示意图"> nums指向的地址，地址中又有很多地址，指向其他（已经存在的数据)</p><h3 id="while循环" tabindex="-1">while循环 <a class="header-anchor" href="#while循环" aria-label="Permalink to &quot;while循环&quot;">​</a></h3><p>while 判断条件: 循环体 注意：<strong>如果循环体中，满足判断条件的变量（<code>i</code>）不变化，那么就是死循环了</strong><code>i</code>：循环变量初始化</p><p>注意事项： while 也可以和 else配合使用 while 判断条件: 循环体 else: 循环体 执行场景：在while-else判断条件为false时，会执行else语句块。也就是在遍历过程中，没有被打断(没有执行到break语句)</p><p>for循环和while循环的区别： while是如果一个条件没有false，就会一直执行 但for 是在一个范围区间内进行循环</p><h3 id="多重循环控制-难点、重点" tabindex="-1">多重循环控制（难点、重点） <a class="header-anchor" href="#多重循环控制-难点、重点" aria-label="Permalink to &quot;多重循环控制（难点、重点）&quot;">​</a></h3><p>如果外层循环是m次，内层循环是n次，那么内层循环实际执行次数是m*n次</p><p>如果在<code>print</code>语句中，加上<code>end = &quot;&quot;</code>表示输出不换行</p><p><strong>for循环，变量不清零？</strong></p><h3 id="break语句" tabindex="-1">break语句 <a class="header-anchor" href="#break语句" aria-label="Permalink to &quot;break语句&quot;">​</a></h3><p>random模块中randint()函数可以生成随机数，语法为：<code>random.randint(a,b)</code> 意思是返回随机整数N，满足a&lt;=N&lt;=b，相当于range(a,b+1)</p><p>循环体中，当判断条件成立，会执行break，之后会<strong>退出当前循环</strong> 1、<code>break语句用在</code><strong>for/while</strong>循环中，会<strong>终结最近的外层循环</strong> 2、如果循环中出现<code>else</code>语句，遇到break也会直接跳过该语句 3、如果一个<code>for</code>循环被<code>break</code>终结，该循环的控制变量会<strong>保持当前值</strong></p><h3 id="continue" tabindex="-1">continue <a class="header-anchor" href="#continue" aria-label="Permalink to &quot;continue&quot;">​</a></h3><p>1、用于<code>for/while</code>循环中 2、用于结束本次循环（非终止循环），<strong>继续执行</strong>循环的下一轮次 继续执行的是，该continue最近的外层循环的下一轮次 一旦执行到continue，<strong>当前循环的下面其他代码就不再执行了（结束本次循环），而是直接执行下一轮次的判断条件</strong></p><blockquote><p>一个是结束本次循环，进行下一次； 另一个是退出当前最近的循环，进行下面的语句(?)</p></blockquote><h3 id="return" tabindex="-1">return <a class="header-anchor" href="#return" aria-label="Permalink to &quot;return&quot;">​</a></h3><p>跳出函数，<strong>该函数中的所有代码</strong>都不会再去执行 你在哪个地方调用的，就跳到哪个位置（也就是回到调用函数的位置） 如果没有<code>return</code>语句的话，默认返回None，通常代表空值的对象</p><h4 id="编程思想" tabindex="-1">编程思想 <a class="header-anchor" href="#编程思想" aria-label="Permalink to &quot;编程思想&quot;">​</a></h4><p>1、化繁为简：把复杂需求拆解成简单的需求，一步步完成 把一个较为复杂、较为综合的任务，拆解成简单的任务，本身也是一种能力</p><p>2、先死后活：考虑具体需求的时候，先考虑固定的东西，将其实现，然后再考虑活的东西</p><p>3、不管题目简单还是复杂，一定要拆解之后再走代码。当你的项目/题目到了一定的量，就可以不用写了</p><h2 id="学-和习" tabindex="-1">学，和习 <a class="header-anchor" href="#学-和习" aria-label="Permalink to &quot;学，和习&quot;">​</a></h2><p>编程就像游泳一样，仅仅是听到了技巧并无法保证自己真正学会，真正下水的时候，还是会有各种意外 如果只听，但是不练习，是没有任何用的。真正使用到的时候，可能并不单纯是知识点，而是知识线，甚至知识面。 如何精进自己： 1、多听，听懂 2、多思考，用自己的话，把知识点重复一遍 3、多练，练过的题，讲过的题，多练习才能知道<strong>实际的应用场景</strong> 4、多总结，总结出来之后(其实也就形成自己的知识框架)，再次看到，还可以想到自己是如何学的</p><h2 id="函数" tabindex="-1">函数 <a class="header-anchor" href="#函数" aria-label="Permalink to &quot;函数&quot;">​</a></h2><p>定义：完成某一功能的程序指令/语句的集合 某个功能、多条语句 分类： 1、系统函数 内置函数；模块函数 2、自定义函数 好处： 1、代码复用性、且方便维护 2、将细节封装起来，供其他用户调用</p><p>形参：定义的时候指定的； 实参：调用的时候传进去的</p><p>函数的思路分析： 1、函数名；2、形参列表；3、函数体 函数定义了，如果不调用，是不会自动执行的 cry()：就是调用函数</p><p>return跳出函数的时候，如果后面有值，可以再赋给其他的变量，当然也可以直接返回。</p><h3 id="调用函数" tabindex="-1">调用函数 <a class="header-anchor" href="#调用函数" aria-label="Permalink to &quot;调用函数&quot;">​</a></h3><p>程序员调用函数，就像下达任务一样，这时候会有一些参数传入。然后函数返回结果</p><p><img src="'+p+'" alt="函数调用栈示意图"> 代码执行的时候会开辟新的栈，一般成为主栈。栈和栈之间是独立的空间。主栈意味着代码开始执行。 编译器每遇到一个函数，就会开辟一个新栈（新栈可以理解为是一个独立的空间) 一旦执行某一个函数，就会进入到对应的函数代码，把实参传给相应的形参 数据区，是存放数据的，放值的。 return表示跳出函数，如果后面有值的话，会把值返回，<strong>在哪个地方调用的，就返回到哪里</strong> 整个程序执行完毕后，开辟的数据区、代码区、栈区都会被回收</p><h3 id="注意事项-1" tabindex="-1">注意事项 <a class="header-anchor" href="#注意事项-1" aria-label="Permalink to &quot;注意事项&quot;">​</a></h3><p>1、函数中的变量是局部的，函数外不生效 2、两个函数名相同的函数，在同一个文件，调用的时候遵循就近原则（其它语言中会报错，但是Python语言中允许两个同名函数） Python中没有函数重载（Java中有）：根据参数不同，调用不同 3、传参的时候，有一种是位置传参。其中定义的<strong>形参，不用指定数据类型，会根据传入的实参来决定</strong> 4、函数允许返回多个值，返回的数据类型不受限制 5、函数支持关键字参数，也就是：函数调用的时候，可以通过&quot;形参名=实参值&quot;的形式传递参数。可以不受上面(位置传参)的限制 （在传递实参中）price = 90</p><p>6、函数支持默认参数(缺省函数)：定义函数时，可以给参数提供默认值，调用时，如果提供了指定的值，就用指定的，如果没有，就用默认的。默认值写在形参等号后，且有默认值的要在最后放着</p><p>7、函数支持可变参数(不定长参数)： 应用场景：调用函数的时候，不确定传入多少个实参。比如求多个数的和 传入的多个实参，会被组成一个元组(tuple)（元组就是可以储存多个数据项的） 具体使用：<strong>(星号*)通常表示[0到多]</strong> <code>def sum(*args)</code></p><p>8、函数的可变参数，还支持多个关键字函数，也就是说支持&quot;参数名=实参值&quot;的形式 关键字函数：<code>price=90</code>(实参中) 应用场景：调用函数时，不确定传入多少个关键字参数的情况 传入的多个关键字参数，会组成一个字典(dict)（字典可以储存多个<code>键=值</code>的数据项） 具体使用：<code>def 函数名(**args)</code>：一个星是多个未知的参数，现在是关键字可变参数</p><p>9、Python可以调用另一个.py文件中的函数 想在f2.py文件中调用f1.py的函数，可以先导入，然后再用文件名.函数名即可（这个文件其实就是模块，Python中，一个文件就是一个模块） import f1 f1.add(实参)</p><p>以上这些没有什么编程思想的东西，你自己看书的时候，一直在记这些……所以某种程度上，还是有个老师好啊</p><h3 id="传参机制" tabindex="-1">传参机制 <a class="header-anchor" href="#传参机制" aria-label="Permalink to &quot;传参机制&quot;">​</a></h3><h4 id="字符串和数值类型的传参机制" tabindex="-1">字符串和数值类型的传参机制 <a class="header-anchor" href="#字符串和数值类型的传参机制" aria-label="Permalink to &quot;字符串和数值类型的传参机制&quot;">​</a></h4><p>1、数值类型传参机制：</p><blockquote><p>调用函数会开一个新栈；函数调用完毕会返回原来开始调用的地方</p></blockquote><p><img src="'+s+'" alt="数值类型传参机制"> 函数内<code>a</code>的加减，并不影响函数外的<code>a</code> 而且不管是数值，还是字符串，都会存在驻留机制，所以在参数刚传入进函数的时候，函数外的<code>a</code>和内的<code>a</code>指向都是一样的</p><p>2、字符串类型传参机制</p><p><img src="'+d+'" alt="字符串类型传参机制"></p><p>3、结论：</p><p>字符串和数值类型是不可变数据类型：当对应的变量的值发生了变化，它对应的内存地址也会发生改变 可变数据类型：指向的空间没有变，地址没有变，但是里面的数据改变了； 不可变数据类型：指向的空间改变，地址改变。</p><h3 id="递归调用-recursion" tabindex="-1">递归调用(recursion) <a class="header-anchor" href="#递归调用-recursion" aria-label="Permalink to &quot;递归调用(recursion)&quot;">​</a></h3><p>传参机制和调用机制是理解递归调用的基础。 各种算法中也会使用到递归。</p><p>先把机制理解了，才可能有后续更复杂的代码</p>',167)]))}const k=e(c,[["render",u]]);export{x as __pageData,k as default};
